**Challenge:** EVEN RSA CAN BE BROKEN???

**Level:** Easy

**Challenge Author:** Michael Crotty

### Description: 
This service provides you an encrypted flag. Can you decrypt it with just N & e?

- webshell: ```nc verbal-sleep.picoctf.net 52407```

### Step-by-Step Walkthrough:
The webshell host gives us N and e and then quits. Connecting additional times provides us with a new value of N and e each time. I'm not as familiar with RSA as I could be, so I relied on Github CoPilot to help me with the steps. I'll provide the steps and attempt to explain what's going on. My variables for this puzzle I used was:

N: 22676125927086140667609347516529909554756457877786909205642696299234458896535525596298160022820418011501793592227590346161977221584544540547913348062440766 

e: 65537

cipher: 9636682935258649179130909110747459727231888165011746758069407739205500025175900947974232789596737805227400882981230970611996750623457231492215973082253413


### What is RSA


### Decrypting RSA token
To decrypt the RSA token generated in the current code file, you need the private key ```d```, which is calculated using the formula: ```d = inverse(e, (p-1)*(q-1))```

Here, ```p``` and ```q``` are the prime factors of ```N```. Without ```p``` and ```q```, it is computationally infeasible to calculate d directly, as factoring ```N``` is the core difficulty of RSA encryption.

1. Factorize N:

You need to find the prime factors ```p``` and ```q``` of ```N```. This is the hardest part of breaking RSA encryption. If ```N``` is small or poorly generated, you might use tools like YAFU or Msieve to factorize it.

I used native python tools to find the important factors, I'll post my code here

```
from sympy import factorint

N = 22676125927086140667609347516529909554756457877786909205642696299234458896535525596298160022820418011501793592227590346161977221584544540547913348062440766

# Factorize N
factors = factorint(N)
print(factors)  # This will return {p: 1, q: 1} if successful
```

the result returned immediately, and it's not hard to understand why. I'll post the results.

```
p = 2
q = 11338062963543070333804673758264954777378228938893454602821348149617229448267762798149080011410209005750896796113795173080988610792272270273956674031220383
```

As you can imagine, p = 2 is atypical. The factors are supposed to be odd to avoid simple cracking of the RSA cipher. This is the hidden detail that makes this not just possible, but actually very simple


2. Compute Ï†(N):

```phi = (p - 1) * (q - 1)```

3. Calculate d

```d = inverse(e, phi)```

4. Decrypt the ciphertext

```
plaintext = pow(ciphertext, d, N)
print(long_to_bytes(plaintext).decode('utf-8'))
```

All of the code above was simply generated by github copilot, making it easy to quickly identify the problem and code up a solution. It was even correct the first time ha.

### Notes:
- If N is large and properly generated, factorization is computationally infeasible without significant resources.
- If you cannot factorize N, you cannot decrypt the ciphertext without access to the private key.

<details><summary>Flag</summary>
    <pre>
    picoCTF{tw0_1$_pr!m3605cd50e}
    </pre>
   </details>
